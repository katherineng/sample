     _          _ _ 
 ___| |__   ___| | |
/ __| '_ \ / _ \ | |
\__ \ | | |  __/ | |
|___/_| |_|\___|_|_| Katherine Ng <kwng>


PART 1

All the program variables are initialized within the main method to avoid the use of global variables. Pointers to these variables are passed as parameters into the helper functions. The buffer buf in which read() stores its output has a fixed size of 1024, and is immediately initialized on the stack. The buffers that are used to store the command line (without the redirection parts) and the working directory path are also initialized on the stack with a fixed size of 1024 because there is no way of knowing the length of the command line string or working directory string before the respective buffers need to be used. The variables used to store the input redirection file and output redirection file, however, were initialized on the heap because the strlen() function could be used to find the appropriate size needed for the char array. Other variables include a character pointer which points to a character in the buffer buf to keep track of the current position during command line parsing; a boolean quit, which is initially set to false; booleans input_redirect and output_redirect, which keep track of whether or not there is input and/or output redirection; and a boolean trunc_file, which keeps track of whether output redirection should be truncated or appended.

While the user has not exited from the shell, the shell prints the current working directory and the prompt $ to stdout. It them attempts to read user input into the buffer buf. The command line is parsed by searching for occurences of < or >. The helper method parse_redirect() is then called to store the filenames associated with the redirection symbol in the file_in and file_out declared in main(). parse_redirect() is also responsible for using malloc() to initialize file_in and file_out on the heap. Meanwhile, the parts of the command line that are not related to redirection are stored in a separate buffer cmd_line, which is later parsed using helper method parse_command(). parse_command() determines whether the command is a built-in function or an external program. If it is built-in, it then calls the corresponding helper function, otherwise it calls exec_extern(), which is responsible for calling fork() to create a child process.

Within the child process, file_redirect() is called to set stdin and stdout to the input and output files specified by the user (if any). For output redirection, file_redirect sets the default permissions of newly created files with the mask S_IWRXU (0700). Before redirecting input or output, exec_extern() checks to see if the command exists. Although the execve() system call automatically does this, this functionality is also implemented in exec_extern() before fork() is called to ensure that file redirection does not occur if no command or a non-existant command is entered. This prevents existing files from being overwritten if output redirection is specified but a command is not. Then, fork() is called and the parent process waits for the child process to return before resuming.


PART 2

For this part of shell, the program variables were stored globally to avoid having to pass them as parameters to all the helper functions. Variables include my_jobs, a pointer to a job_list_t, which stores all the currently running jobs; next_id, which is initialized to 1 in the beginning, then is incremented when a new job is started as a simple way to create unique job ids; status, which stores the program status of children that send SIG_CHLD to the parent; and fg_pid, which is used to keep track of foreground processes. When there is no foreground process (i.e. when the shell is interactive) fg_pid is set to zero. Otherwise, it is set to the pid (and therefore the pgid) of the child process that is running in the foreground. When fg_pid is not zero, the shell goes into a busy loop and waits for the foreground process to stop, exit or terminate. 

The handlers for SIGTSTP, SIGINT, SIGQUIT, and SIGCHLD are installed in the main method using the wrapper function install_handler(). SIGTSTP, SIGINT, and SIGQUIT share a handler, which simply forwards the signal to a foreground child process (if any) using kill(). SIGCHLD has its own handler child_handler(), which calls waitpid() with the flags WNOHANG, WUNTRACED, and WCONTINUED to determine the pid of a child process that sends SIGCHLD to the parent. If a job exits or is terminated, the handler calls remove_job_pid() to reap the zombie child process, and resets fg_pid to 0 if the child was the foreground process. If a child process is stopped or continued, child_handler() calls update_job_pid to change the status, and for stopped process, fg_pid is reset to 0 if the stopped child was a foreground process.

In order to allow the foreground child process to read from stdin, terminal control is transferred to foreground child process in the helper function reassign_tc() using tcsetpgrp() and then restored to shell when the shell breaks out of the busy loop. Since tcsetpgrp() results in a SIGTTOU signal being sent, calls to tcsetpgrp() are wrapped in calls to sigprocmask, which block SIGTTOU for the duration of the call to tcsetpgrp(). If a background child process attempts to read from stdin, it is stopped by SIGTTIN, and will send a SIGCHLD to the parent process. Thus, any child that reads from stdin that is started as a background process will immediately be stopped.

Finally, the builtin commands fg, bg, and jobs were added. jobs simply calls the jobs() from jobs.c on my_jobs. bg sets fg_pid to zero and sends a SIGCONT to the child process using kill(). fg does the same thing as bg except it must set fg_pid to the pid of the child process that is being restarted and transfer terminal control to the child process before calling kill() with SIGCONT. It then enters into a busy loop until fg_pid is reset to 0, at which point terminal control is returned to the shell.


